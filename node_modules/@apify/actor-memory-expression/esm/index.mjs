var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/memory_calculator.ts
import {
  addDependencies,
  andDependencies,
  compileDependencies,
  create,
  divideDependencies,
  evaluateDependencies,
  maxDependencies,
  minDependencies,
  multiplyDependencies,
  notDependencies,
  nullishDependencies,
  orDependencies,
  subtractDependencies,
  xorDependencies
} from "mathjs";
import { ACTOR_LIMITS } from "@apify/consts";
var DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH = 1e3;
var ALLOWED_RUN_OPTION_KEYS = /* @__PURE__ */ new Set([
  "build",
  "timeoutSecs",
  "memoryMbytes",
  "diskMbytes",
  "maxItems",
  "maxTotalChargeUsd",
  "restartOnError"
]);
var math = create({
  // expression dependencies
  // Required for compiling and evaluating root expressions.
  // We disable it below to prevent users from calling `evaluate()` inside their expressions.
  // For example: defaultMemoryMbytes = "evaluate('2 + 2')"
  compileDependencies,
  evaluateDependencies,
  // arithmetic dependencies
  addDependencies,
  subtractDependencies,
  multiplyDependencies,
  divideDependencies,
  // statistics dependencies
  maxDependencies,
  minDependencies,
  // logical dependencies
  andDependencies,
  notDependencies,
  orDependencies,
  xorDependencies,
  // without that dependency 'null ?? 5', won't work
  nullishDependencies
});
var { compile } = math;
math.import({
  // We disable evaluate to prevent users from calling it inside their expressions.
  // For example: defaultMemoryMbytes = "evaluate('2 + 2')"
  evaluate() {
    throw new Error("Function evaluate is disabled.");
  },
  compile() {
    throw new Error("Function compile is disabled.");
  },
  // We need to disable it, because compileDependencies imports parseDependencies.
  parse() {
    throw new Error("Function parse is disabled.");
  }
}, { override: true });
var customGetFunc = /* @__PURE__ */ __name((obj, path, defaultVal) => {
  return path.split(".").reduce((current, key) => current?.[key], obj) ?? defaultVal;
}, "customGetFunc");
var roundToClosestPowerOf2 = /* @__PURE__ */ __name((num) => {
  if (typeof num !== "number" || Number.isNaN(num) || !Number.isFinite(num)) {
    throw new Error(`Calculated memory value is not a valid number: ${num}.`);
  }
  if (num <= 0) {
    throw new Error(`Calculated memory value must be a positive number, greater than 0, got: ${num}.`);
  }
  const log2n = Math.log2(num);
  const roundedLog = Math.round(log2n);
  const result = 2 ** roundedLog;
  return Math.max(ACTOR_LIMITS.MIN_RUN_MEMORY_MBYTES, Math.min(result, ACTOR_LIMITS.MAX_RUN_MEMORY_MBYTES));
}, "roundToClosestPowerOf2");
var processTemplateVariables = /* @__PURE__ */ __name((defaultMemoryMbytes) => {
  const variableRegex = /{{\s*([a-zA-Z0-9_.]+)\s*}}/g;
  const processedExpression = defaultMemoryMbytes.replace(
    variableRegex,
    (_, variableName) => {
      if (variableName.startsWith("input.")) {
        return variableName;
      }
      if (variableName.startsWith("runOptions.")) {
        const key = variableName.slice("runOptions.".length);
        if (!ALLOWED_RUN_OPTION_KEYS.has(key)) {
          throw new Error(
            `Invalid variable '{{${variableName}}}' in expression. Only the following runOptions are allowed: ${Array.from(ALLOWED_RUN_OPTION_KEYS).map((k) => `runOptions.${k}`).join(", ")}.`
          );
        }
        return variableName;
      }
      throw new Error(
        `Invalid variable '{{${variableName}}}' in expression.`
      );
    }
  );
  return processedExpression;
}, "processTemplateVariables");
var getCompiledExpression = /* @__PURE__ */ __name(async (expression, cache) => {
  if (!cache) {
    return compile(expression);
  }
  let compiledExpression = await cache.get(expression);
  if (!compiledExpression) {
    compiledExpression = compile(expression);
    await cache.set(expression, compiledExpression);
  }
  return compiledExpression;
}, "getCompiledExpression");
var calculateRunDynamicMemory = /* @__PURE__ */ __name(async (defaultMemoryMbytes, context, options = void 0) => {
  if (defaultMemoryMbytes.length > DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH) {
    throw new Error(`The defaultMemoryMbytes expression is too long. Max length is ${DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH} characters.`);
  }
  const preprocessedExpression = processTemplateVariables(defaultMemoryMbytes);
  const preparedContext = {
    ...context,
    get: customGetFunc
  };
  const compiledExpression = await getCompiledExpression(preprocessedExpression, options?.cache);
  let finalResult = compiledExpression.evaluate(preparedContext);
  if (finalResult && typeof finalResult === "object" && "entries" in finalResult) {
    const { entries } = finalResult;
    finalResult = entries[entries.length - 1];
  }
  return roundToClosestPowerOf2(finalResult);
}, "calculateRunDynamicMemory");
export {
  DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH,
  calculateRunDynamicMemory
};
//# sourceMappingURL=index.mjs.map