"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH: () => DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH,
  calculateRunDynamicMemory: () => calculateRunDynamicMemory
});
module.exports = __toCommonJS(index_exports);

// src/memory_calculator.ts
var import_mathjs = require("mathjs");
var import_consts = require("@apify/consts");
var DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH = 1e3;
var ALLOWED_RUN_OPTION_KEYS = /* @__PURE__ */ new Set([
  "build",
  "timeoutSecs",
  "memoryMbytes",
  "diskMbytes",
  "maxItems",
  "maxTotalChargeUsd",
  "restartOnError"
]);
var math = (0, import_mathjs.create)({
  // expression dependencies
  // Required for compiling and evaluating root expressions.
  // We disable it below to prevent users from calling `evaluate()` inside their expressions.
  // For example: defaultMemoryMbytes = "evaluate('2 + 2')"
  compileDependencies: import_mathjs.compileDependencies,
  evaluateDependencies: import_mathjs.evaluateDependencies,
  // arithmetic dependencies
  addDependencies: import_mathjs.addDependencies,
  subtractDependencies: import_mathjs.subtractDependencies,
  multiplyDependencies: import_mathjs.multiplyDependencies,
  divideDependencies: import_mathjs.divideDependencies,
  // statistics dependencies
  maxDependencies: import_mathjs.maxDependencies,
  minDependencies: import_mathjs.minDependencies,
  // logical dependencies
  andDependencies: import_mathjs.andDependencies,
  notDependencies: import_mathjs.notDependencies,
  orDependencies: import_mathjs.orDependencies,
  xorDependencies: import_mathjs.xorDependencies,
  // without that dependency 'null ?? 5', won't work
  nullishDependencies: import_mathjs.nullishDependencies
});
var { compile } = math;
math.import({
  // We disable evaluate to prevent users from calling it inside their expressions.
  // For example: defaultMemoryMbytes = "evaluate('2 + 2')"
  evaluate() {
    throw new Error("Function evaluate is disabled.");
  },
  compile() {
    throw new Error("Function compile is disabled.");
  },
  // We need to disable it, because compileDependencies imports parseDependencies.
  parse() {
    throw new Error("Function parse is disabled.");
  }
}, { override: true });
var customGetFunc = /* @__PURE__ */ __name((obj, path, defaultVal) => {
  return path.split(".").reduce((current, key) => current?.[key], obj) ?? defaultVal;
}, "customGetFunc");
var roundToClosestPowerOf2 = /* @__PURE__ */ __name((num) => {
  if (typeof num !== "number" || Number.isNaN(num) || !Number.isFinite(num)) {
    throw new Error(`Calculated memory value is not a valid number: ${num}.`);
  }
  if (num <= 0) {
    throw new Error(`Calculated memory value must be a positive number, greater than 0, got: ${num}.`);
  }
  const log2n = Math.log2(num);
  const roundedLog = Math.round(log2n);
  const result = 2 ** roundedLog;
  return Math.max(import_consts.ACTOR_LIMITS.MIN_RUN_MEMORY_MBYTES, Math.min(result, import_consts.ACTOR_LIMITS.MAX_RUN_MEMORY_MBYTES));
}, "roundToClosestPowerOf2");
var processTemplateVariables = /* @__PURE__ */ __name((defaultMemoryMbytes) => {
  const variableRegex = /{{\s*([a-zA-Z0-9_.]+)\s*}}/g;
  const processedExpression = defaultMemoryMbytes.replace(
    variableRegex,
    (_, variableName) => {
      if (variableName.startsWith("input.")) {
        return variableName;
      }
      if (variableName.startsWith("runOptions.")) {
        const key = variableName.slice("runOptions.".length);
        if (!ALLOWED_RUN_OPTION_KEYS.has(key)) {
          throw new Error(
            `Invalid variable '{{${variableName}}}' in expression. Only the following runOptions are allowed: ${Array.from(ALLOWED_RUN_OPTION_KEYS).map((k) => `runOptions.${k}`).join(", ")}.`
          );
        }
        return variableName;
      }
      throw new Error(
        `Invalid variable '{{${variableName}}}' in expression.`
      );
    }
  );
  return processedExpression;
}, "processTemplateVariables");
var getCompiledExpression = /* @__PURE__ */ __name(async (expression, cache) => {
  if (!cache) {
    return compile(expression);
  }
  let compiledExpression = await cache.get(expression);
  if (!compiledExpression) {
    compiledExpression = compile(expression);
    await cache.set(expression, compiledExpression);
  }
  return compiledExpression;
}, "getCompiledExpression");
var calculateRunDynamicMemory = /* @__PURE__ */ __name(async (defaultMemoryMbytes, context, options = void 0) => {
  if (defaultMemoryMbytes.length > DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH) {
    throw new Error(`The defaultMemoryMbytes expression is too long. Max length is ${DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH} characters.`);
  }
  const preprocessedExpression = processTemplateVariables(defaultMemoryMbytes);
  const preparedContext = {
    ...context,
    get: customGetFunc
  };
  const compiledExpression = await getCompiledExpression(preprocessedExpression, options?.cache);
  let finalResult = compiledExpression.evaluate(preparedContext);
  if (finalResult && typeof finalResult === "object" && "entries" in finalResult) {
    const { entries } = finalResult;
    finalResult = entries[entries.length - 1];
  }
  return roundToClosestPowerOf2(finalResult);
}, "calculateRunDynamicMemory");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH,
  calculateRunDynamicMemory
});
//# sourceMappingURL=index.cjs.map