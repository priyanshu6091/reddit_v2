{"version":3,"sources":["../../src/memory_calculator.ts"],"sourcesContent":["// MathJS bundle with only numbers is ~2x smaller than the default one.\nimport {\n    addDependencies,\n    andDependencies,\n    compileDependencies,\n    create,\n    divideDependencies,\n    evaluateDependencies,\n    maxDependencies,\n    minDependencies,\n    multiplyDependencies,\n    notDependencies,\n    // @ts-expect-error nullishDependencies is not declared in types. https://github.com/josdejong/mathjs/issues/3597\n    nullishDependencies,\n    orDependencies,\n    subtractDependencies,\n    xorDependencies,\n} from 'mathjs';\n\nimport { ACTOR_LIMITS } from '@apify/consts';\n\nimport type { ActorRunOptions, CompilationCache, CompilationResult, MemoryEvaluationContext } from './types.js';\n\n// In theory, users could create expressions longer than 1000 characters,\n// but in practice, it's unlikely anyone would need that much complexity.\n// Later we can increase this limit if needed.\nexport const DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH = 1000;\n\n/**\n * A Set of allowed keys from ActorRunOptions that can be used in\n * the {{runOptions.variable}} syntax.\n */\nconst ALLOWED_RUN_OPTION_KEYS = new Set<keyof ActorRunOptions>([\n    'build',\n    'timeoutSecs',\n    'memoryMbytes',\n    'diskMbytes',\n    'maxItems',\n    'maxTotalChargeUsd',\n    'restartOnError',\n]);\n\n/**\n * Create a mathjs instance with selected dependencies, then disable potentially dangerous ones.\n * MathJS security recommendations: https://mathjs.org/docs/expressions/security.html\n */\nconst math = create({\n    // expression dependencies\n    // Required for compiling and evaluating root expressions.\n    // We disable it below to prevent users from calling `evaluate()` inside their expressions.\n    // For example: defaultMemoryMbytes = \"evaluate('2 + 2')\"\n    compileDependencies,\n    evaluateDependencies,\n\n    // arithmetic dependencies\n    addDependencies,\n    subtractDependencies,\n    multiplyDependencies,\n    divideDependencies,\n    // statistics dependencies\n    maxDependencies,\n    minDependencies,\n    // logical dependencies\n    andDependencies,\n    notDependencies,\n    orDependencies,\n    xorDependencies,\n    // without that dependency 'null ?? 5', won't work\n    nullishDependencies,\n});\nconst { compile } = math;\n\n// Disable potentially dangerous functions\nmath.import({\n    // We disable evaluate to prevent users from calling it inside their expressions.\n    // For example: defaultMemoryMbytes = \"evaluate('2 + 2')\"\n    evaluate() { throw new Error('Function evaluate is disabled.'); },\n    compile() { throw new Error('Function compile is disabled.'); },\n    // We need to disable it, because compileDependencies imports parseDependencies.\n    parse() { throw new Error('Function parse is disabled.'); },\n}, { override: true });\n\n/**\n * Safely retrieves a nested property from an object using a dot-notation string path.\n *\n * This is custom function designed to be injected into the math expression evaluator,\n * allowing expressions like `get(input, 'user.settings.memory', 512)` or `get(input, 'startUrls.length', 10)` to get array length.\n *\n * @param obj The source object to search within.\n * @param path A dot-separated string representing the nested path (e.g., \"input.payload.size\").\n * @param defaultVal The value to return if the path is not found or the value is `null` or `undefined`.\n * @returns The retrieved value, or `defaultVal` if the path is unreachable.\n*/\nconst customGetFunc = (obj: any, path: string, defaultVal?: number) => {\n    return (path.split('.').reduce((current, key) => current?.[key], obj)) ?? defaultVal;\n};\n\n/**\n * Rounds a number to the closest power of 2.\n * The result is clamped to the allowed range (ACTOR_LIMITS.MIN_RUN_MEMORY_MBYTES - ACTOR_LIMITS.MAX_RUN_MEMORY_MBYTES).\n * @param num The number to round.\n * @returns The closest power of 2 within min/max range.\n*/\nconst roundToClosestPowerOf2 = (num: number): number => {\n    if (typeof num !== 'number' || Number.isNaN(num) || !Number.isFinite(num)) {\n        throw new Error(`Calculated memory value is not a valid number: ${num}.`);\n    }\n\n    // Handle 0 or negative values.\n    if (num <= 0) {\n        throw new Error(`Calculated memory value must be a positive number, greater than 0, got: ${num}.`);\n    }\n\n    const log2n = Math.log2(num);\n\n    const roundedLog = Math.round(log2n);\n    const result = 2 ** roundedLog;\n\n    return Math.max(ACTOR_LIMITS.MIN_RUN_MEMORY_MBYTES, Math.min(result, ACTOR_LIMITS.MAX_RUN_MEMORY_MBYTES));\n};\n\n/**\n * Replaces all `{{variable}}` placeholders in an expression into direct\n * property access (e.g. `{{runOptions.memoryMbytes}}` â†’ `runOptions.memoryMbytes`).\n *\n * All `input.*` values are accepted, while `runOptions.*` are validated (7 variables from ALLOWED_RUN_OPTION_KEYS).\n *\n * Note: While not really needed for Math.js, this approach allows developers\n * to use a consistent double-brace templating syntax `{{runOptions.timeoutSecs}}`\n * across the Apify platform. We also want to avoid compiling the expression with the\n * actual values as that would make caching less effective.\n *\n * @example\n * // Returns \"runOptions.memoryMbytes + 1024\"\n * preprocessDefaultMemoryExpression(\"{{runOptions.memoryMbytes}} + 1024\");\n *\n * @param defaultMemoryMbytes The raw string expression, e.g., \"{{runOptions.memoryMbytes}} * 2\".\n * @returns A safe, processed expression for evaluation, e.g., \"runOptions.memoryMbytes * 2\".\n */\nconst processTemplateVariables = (defaultMemoryMbytes: string): string => {\n    const variableRegex = /{{\\s*([a-zA-Z0-9_.]+)\\s*}}/g;\n\n    const processedExpression = defaultMemoryMbytes.replace(\n        variableRegex,\n        (_, variableName: string) => {\n            // 1. Check if the variable is accessing input (e.g. {{input.someValue}})\n            // We do not validate the specific property name because `input` is dynamic.\n            if (variableName.startsWith('input.')) {\n                return variableName;\n            }\n\n            // 2. Check if the variable is accessing runOptions (e.g. {{runOptions.memoryMbytes}}) and validate the keys.\n            if (variableName.startsWith('runOptions.')) {\n                const key = variableName.slice('runOptions.'.length);\n                if (!ALLOWED_RUN_OPTION_KEYS.has(key as keyof ActorRunOptions)) {\n                    throw new Error(\n                        `Invalid variable '{{${variableName}}}' in expression. Only the following runOptions are allowed: ${Array.from(ALLOWED_RUN_OPTION_KEYS).map((k) => `runOptions.${k}`).join(', ')}.`,\n                    );\n                }\n                return variableName;\n            }\n\n            // 3. Throw error for unrecognized variables (e.g. {{someVariable}})\n            throw new Error(\n                `Invalid variable '{{${variableName}}}' in expression.`,\n            );\n        },\n    );\n\n    return processedExpression;\n};\n\n/*\n* Retrieves a compiled expression from the cache or compiles it if not present.\n*\n* @param expression The expression string to compile.\n* @param cache An optional cache to store/retrieve compiled expressions.\n* @returns The compiled CompilationResult.\n*/\nconst getCompiledExpression = async (expression: string, cache: CompilationCache | undefined): Promise<CompilationResult> => {\n    if (!cache) {\n        return compile(expression);\n    }\n\n    let compiledExpression = await cache.get(expression);\n\n    if (!compiledExpression) {\n        compiledExpression = compile(expression);\n        await cache.set(expression, compiledExpression!);\n    }\n\n    return compiledExpression;\n};\n\n/**\n * Evaluates a dynamic memory expression string using the provided context.\n * Result is rounded to the closest power of 2 and clamped within allowed limits.\n *\n * @param defaultMemoryMbytes The string expression to evaluate (e.g., `get(input, 'urls.length', 10) * 1024` for `input = { urls: ['url1', 'url2'] }`).\n * @param context The `MemoryEvaluationContext` (containing `input` and `runOptions`) available to the expression.\n * @param options.cache Optional synchronous cache. Since compiled functions cannot be saved to a database/Redis, they are kept in local memory.\n * @returns The calculated memory value rounded to the closest power of 2 and clamped within allowed limits.\n*/\nexport const calculateRunDynamicMemory = async (\n    defaultMemoryMbytes: string,\n    context: MemoryEvaluationContext,\n    options: { cache: CompilationCache } | undefined = undefined,\n) => {\n    if (defaultMemoryMbytes.length > DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH) {\n        throw new Error(`The defaultMemoryMbytes expression is too long. Max length is ${DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH} characters.`);\n    }\n\n    // Replaces all occurrences of {{variable}} with variable\n    // e.g., \"{{runOptions.memoryMbytes}} + 1024\" becomes \"runOptions.memoryMbytes + 1024\"\n    const preprocessedExpression = processTemplateVariables(defaultMemoryMbytes);\n\n    const preparedContext = {\n        ...context,\n        get: customGetFunc,\n    };\n\n    const compiledExpression = await getCompiledExpression(preprocessedExpression, options?.cache);\n\n    let finalResult: number | { entries: number[] } = compiledExpression.evaluate(preparedContext);\n\n    // Mathjs wraps multi-line expressions in an object, so we need to extract the last entry.\n    // Note: one-line expressions return a number directly.\n    if (finalResult && typeof finalResult === 'object' && 'entries' in finalResult) {\n        const { entries } = finalResult;\n        finalResult = entries[entries.length - 1];\n    }\n\n    return roundToClosestPowerOf2(finalResult);\n};\n"],"mappings":"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","names":[]}