import Ajv, { ErrorObject, ValidateFunction } from 'ajv';
import Ajv$1 from 'ajv/dist/2019';
export { inputSchema } from '@apify/json_schemas';

/**
 * Helper function to simulate intl formatMessage function
 */
declare function m(stringId: string, variables?: Record<string, any>): string;

type CommonFieldDefinition<T> = {
    title: string;
    description: string;
    default?: T;
    prefill?: T;
    example?: T;
    nullable?: boolean;
    sectionCaption?: string;
    sectionDescription?: string;
};
type StringFieldDefinition = CommonFieldDefinition<string> & {
    type: 'string';
    editor: 'textfield' | 'textarea' | 'javascript' | 'python' | 'select' | 'datepicker' | 'hidden' | 'json' | 'fileupload';
    pattern?: string;
    minLength?: number;
    maxLength?: number;
    enum?: readonly string[];
    enumTitles?: readonly string[];
    enumSuggestedValues?: readonly string[];
    isSecret?: boolean;
    dateType?: 'absolute' | 'relative' | 'absoluteOrRelative';
};
type BooleanFieldDefinition = CommonFieldDefinition<boolean> & {
    type: 'boolean';
    editor?: 'checkbox' | 'hidden';
    groupCaption?: string;
    groupDescription?: string;
};
type IntegerFieldDefinition = CommonFieldDefinition<number> & {
    type: 'integer';
    editor?: 'number' | 'hidden';
    maximum?: number;
    minimum?: number;
    unit?: string;
};
type NumberFieldDefinition = CommonFieldDefinition<number> & {
    type: 'number';
    editor?: 'number' | 'hidden';
    maximum?: number;
    minimum?: number;
    unit?: string;
};
type ObjectFieldDefinition = CommonFieldDefinition<object> & {
    type: 'object';
    editor: 'json' | 'proxy' | 'schemaBased' | 'hidden';
    patternKey?: string;
    patternValue?: string;
    maxProperties?: number;
    minProperties?: number;
    properties?: Record<string, unknown>;
    required?: string[];
    additionalProperties?: boolean;
};
type ArrayFieldDefinition = CommonFieldDefinition<unknown[]> & {
    type: 'array';
    editor: 'json' | 'requestListSources' | 'pseudoUrls' | 'globs' | 'keyValue' | 'stringList' | 'select' | 'schemaBased' | 'hidden';
    placeholderKey?: string;
    placeholderValue?: string;
    patternKey?: string;
    patternValue?: string;
    maxItems?: number;
    minItems?: number;
    uniqueItems?: boolean;
    items?: unknown;
};
type CommonResourceFieldDefinition<T> = CommonFieldDefinition<T> & {
    editor?: 'resourcePicker' | 'hidden';
    resourceType: 'dataset' | 'keyValueStore' | 'requestQueue';
    resourcePermissions?: ('READ' | 'WRITE')[];
};
type ResourceFieldDefinition = CommonResourceFieldDefinition<string> & {
    type: 'string';
};
type ResourceArrayFieldDefinition = CommonResourceFieldDefinition<string[]> & {
    type: 'array';
    maxItems?: number;
    minItems?: number;
    uniqueItems?: boolean;
};
type AllTypes = StringFieldDefinition['type'] | BooleanFieldDefinition['type'] | IntegerFieldDefinition['type'] | NumberFieldDefinition['type'] | ObjectFieldDefinition['type'] | ArrayFieldDefinition['type'];
type MixedFieldDefinition = CommonFieldDefinition<never> & {
    type: readonly AllTypes[];
    editor: 'json';
};
type FieldDefinition = StringFieldDefinition | BooleanFieldDefinition | IntegerFieldDefinition | NumberFieldDefinition | ObjectFieldDefinition | ArrayFieldDefinition | MixedFieldDefinition | ResourceFieldDefinition | ResourceArrayFieldDefinition;
/**
 * Type with checked base & properties
 */
type InputSchema = {
    type: 'object';
    title: string;
    description?: string;
    schemaVersion: number;
    properties: Record<string, FieldDefinition>;
    required?: readonly string[];
    $schema?: unknown;
};

/**
 * Retrieves a custom error message defined in the schema for a particular schema path.
 * @param rootSchema json schema object
 * @param schemaPath schema path to the failed validation keyword,
 *  as provided in an AJV error object, including the keyword at the end, e.g. "#/properties/name/type"
 */
declare function getCustomErrorMessage(rootSchema: Record<string, any>, schemaPath: string): string | null;
/**
 * This function parses AJV error and transforms it into a readable string.
 *
 * @param error An error as returned from AJV.
 * @param rootName Usually 'input' or 'schema' based on if we are passing the input or schema.
 * @param properties (Used only when parsing input errors) List of input schema properties.
 * @param input (Used only when parsing input errors) Actual input that is being parsed.
 * @returns {null|{fieldKey: *, message: *}}
 */
declare function parseAjvError(error: ErrorObject, rootName: string, properties?: Record<string, {
    nullable?: boolean;
    editor?: string;
}>, input?: Record<string, unknown>): {
    fieldKey: string;
    message: string;
} | null;
/**
 * Validates that all required fields are present in properties list
 */
declare function validateExistenceOfRequiredFields(inputSchema: InputSchema): void;
/**
 * This function validates given input schema first just for basic structure then each field one by one,
 * then checks that all required fields are present and finally checks fully against the whole schema.
 *
 * This way we get the most accurate error message for user.
 *
 * @param validator An instance of AJV validator. Important: The JSON Schema that the passed input schema is validated against
 *  is using features from JSON Schema 2019 draft, so the AJV instance must support it.
 * @param inputSchema Input schema to validate.
 */
declare function validateInputSchema(validator: Ajv, inputSchema: Record<string, unknown>): asserts inputSchema is InputSchema;

/**
 * Uses AJV validator to validate input with input schema and then
 * does custom validation for our own properties (nullable, patternKey, patternValue)
 * @param validator Initialized AJV validator
 * @param inputSchema Valid input schema in object
 * @param input Input object to be validated
 * @param options (Optional) Additional validation configuration for certain fields
 */
declare function validateInputUsingValidator(validator: ValidateFunction, inputSchema: Record<string, any>, input: Record<string, unknown>, options?: Record<string, any>): {
    fieldKey: string;
    message: string;
}[];
/**
 * This functions parses all given JSON and then takes each of the jsFields.
 * Then if the field:
 * - is valid JS single function it replaces its single line string with a function delacation.
 * - is valid multiline JS code then replaces its single line string with `multiline` string
 * Then stringifies the code with given number of jsonSpacing spaces and finally prefixes whole
 * stringified JSON except the first line with globalSpacing spaces.
 */
declare function makeInputJsFieldsReadable(json: string, jsFields: string[], jsonSpacing?: number, globalSpacing?: number): string;
declare function ensureAjvSupportsDraft2019(ajvInstance: Ajv$1): void;
/**
 * Validates that the provided pattern is a valid and safe regular expression.
 * @param pattern The regular expression pattern to validate.
 * @param fieldKey The field key where the pattern is used (for error messages).
 */
declare function validateRegexpPattern(pattern: string, fieldKey: string): void;

export { type ArrayFieldDefinition, type BooleanFieldDefinition, type FieldDefinition, type InputSchema, type IntegerFieldDefinition, type MixedFieldDefinition, type NumberFieldDefinition, type ObjectFieldDefinition, type StringFieldDefinition, ensureAjvSupportsDraft2019, getCustomErrorMessage, m, makeInputJsFieldsReadable, parseAjvError, validateExistenceOfRequiredFields, validateInputSchema, validateInputUsingValidator, validateRegexpPattern };
