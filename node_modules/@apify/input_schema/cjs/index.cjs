"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ensureAjvSupportsDraft2019: () => ensureAjvSupportsDraft2019,
  getCustomErrorMessage: () => getCustomErrorMessage,
  inputSchema: () => import_json_schemas.inputSchema,
  m: () => m,
  makeInputJsFieldsReadable: () => makeInputJsFieldsReadable,
  parseAjvError: () => parseAjvError,
  validateExistenceOfRequiredFields: () => validateExistenceOfRequiredFields,
  validateInputSchema: () => validateInputSchema,
  validateInputUsingValidator: () => validateInputUsingValidator,
  validateRegexpPattern: () => validateRegexpPattern
});
module.exports = __toCommonJS(index_exports);

// src/intl.ts
var intlStrings = {
  "inputSchema.validation.generic": "Field {rootName}.{fieldKey} {message}",
  "inputSchema.validation.required": "Field {rootName}.{fieldKey} is required",
  "inputSchema.validation.proxyRequired": "Field {rootName}.{fieldKey} is required. Please provide custom proxy URLs or use Apify Proxy.",
  "inputSchema.validation.requestListSourcesInvalid": "Items in {rootName}.{fieldKey} at positions [{invalidIndexes}] do not contain valid URLs",
  "inputSchema.validation.arrayKeysInvalid": 'Keys in {rootName}.{fieldKey} at positions [{invalidIndexes}] must match regular expression "{pattern}"',
  "inputSchema.validation.arrayValuesInvalid": 'Values in {rootName}.{fieldKey} at positions [{invalidIndexes}] must match regular expression "{pattern}"',
  "inputSchema.validation.objectKeysInvalid": 'Keys [{invalidKeys}] in {rootName}.{fieldKey} must match regular expression "{pattern}',
  "inputSchema.validation.objectValuesInvalid": 'Keys [{invalidKeys}] in {rootName}.{fieldKey} must have string value which matches regular expression "{pattern}"',
  "inputSchema.validation.additionalProperty": "Property {rootName}.{fieldKey} is not allowed.",
  "inputSchema.validation.proxyGroupsNotAvailable": "You currently do not have access to proxy groups: {groups}",
  "inputSchema.validation.customProxyInvalid": 'Proxy URL "{invalidUrl}" has invalid format, it must be socks[4|4a|5|5h]|http[s]://[username[:password]]@hostname:port.',
  "inputSchema.validation.apifyProxyCountryInvalid": 'Country code "{invalidCountry}" is invalid. Only ISO 3166-1 alpha-2 country codes are supported.',
  "inputSchema.validation.apifyProxyCountryWithoutApifyProxyForbidden": "The country for Apify Proxy can be specified only when using Apify Proxy.",
  "inputSchema.validation.noAvailableAutoProxy": "Currently you do not have access to any proxy group usable in automatic mode.",
  "inputSchema.validation.noMatchingDefinition": "Field schema.properties.{fieldKey} is not matching any input schema type definition. Please make sure that it's type is valid.",
  "inputSchema.validation.missingRequiredField": "Field schema.properties.{fieldKey} does not exist, but it is specified in schema.required. Either define the field or remove it from schema.required.",
  "inputSchema.validation.proxyGroupMustBeArrayOfStrings": "Field {rootName}.{fieldKey}.apifyProxyGroups must be an array of strings.",
  "inputSchema.validation.secretFieldSchemaChanged": "The field schema.properties.{fieldKey} is a secret field, but its schema has changed. Please update the value in the input editor.",
  "inputSchema.validation.regexpNotValid": 'The regular expression "{pattern}" in field schema.properties.{fieldKey} must be valid.',
  "inputSchema.validation.regexpNotSafe": 'The regular expression "{pattern}" in field schema.properties.{fieldKey} may cause excessive backtracking or be unsafe to execute.'
};
function m(stringId, variables) {
  let text = intlStrings[stringId];
  if (!text) return stringId;
  if (variables) {
    Object.keys(variables).forEach((variableName) => {
      text = text.split(`{${variableName}}`).join(variables[variableName]);
    });
  }
  return text;
}
__name(m, "m");

// src/input_schema.ts
var import_json_schemas = require("@apify/json_schemas");

// src/utilities.ts
var import_acorn_loose = require("acorn-loose");
var import_countries_list = require("countries-list");
var import_consts = require("@apify/consts");
var import_input_secrets = require("@apify/input_secrets");
function validateProxyField(fieldKey, value, isRequired = false, options = null) {
  const fieldErrors = [];
  if (isRequired) {
    if (value === null) return fieldErrors;
    if (!value) {
      const message = m("inputSchema.validation.required", { rootName: "input", fieldKey });
      fieldErrors.push(message);
      return fieldErrors;
    }
    const { useApifyProxy: useApifyProxy2, proxyUrls: proxyUrls2 } = value;
    if (!useApifyProxy2 && (!Array.isArray(proxyUrls2) || proxyUrls2.length === 0)) {
      fieldErrors.push(m("inputSchema.validation.proxyRequired", { rootName: "input", fieldKey }));
      return fieldErrors;
    }
  }
  if (!value) return fieldErrors;
  const { useApifyProxy, proxyUrls, apifyProxyGroups, apifyProxyCountry } = value;
  if (!useApifyProxy && Array.isArray(proxyUrls)) {
    let invalidUrl = false;
    proxyUrls.forEach((url) => {
      if (!import_consts.PROXY_URL_REGEX.test(url.trim())) invalidUrl = url.trim();
    });
    if (invalidUrl) {
      fieldErrors.push(m("inputSchema.validation.customProxyInvalid", { invalidUrl }));
    }
  }
  if (!useApifyProxy && apifyProxyCountry) {
    fieldErrors.push(m("inputSchema.validation.apifyProxyCountryWithoutApifyProxyForbidden"));
  }
  if (!useApifyProxy) return fieldErrors;
  if (apifyProxyCountry && !import_countries_list.countries[apifyProxyCountry]) {
    fieldErrors.push(m("inputSchema.validation.apifyProxyCountryInvalid", { invalidCountry: apifyProxyCountry }));
  }
  if (!options) return fieldErrors;
  const isStringsArray = /* @__PURE__ */ __name((array) => array.every((item) => typeof item === "string"), "isStringsArray");
  if (apifyProxyGroups && !(Array.isArray(apifyProxyGroups) && isStringsArray(apifyProxyGroups))) {
    fieldErrors.push(m("inputSchema.validation.proxyGroupMustBeArrayOfStrings", { rootName: "input", fieldKey }));
    return fieldErrors;
  }
  const selectedProxyGroups = apifyProxyGroups || [];
  if (!selectedProxyGroups.length && !options.hasAutoProxyGroups) {
    fieldErrors.push(m("inputSchema.validation.noAvailableAutoProxy"));
    return fieldErrors;
  }
  const availableProxyGroupsById = {};
  (options.availableProxyGroups || []).forEach((group) => {
    availableProxyGroupsById[group] = true;
  });
  const unavailableProxyGroups = selectedProxyGroups.filter((group) => !availableProxyGroupsById[group]);
  if (unavailableProxyGroups.length) {
    fieldErrors.push(m("inputSchema.validation.proxyGroupsNotAvailable", {
      rootName: "input",
      fieldKey,
      groups: unavailableProxyGroups.join(", ")
    }));
  }
  const blockedProxyGroupsById = options.disabledProxyGroups || {};
  selectedProxyGroups.filter((group) => blockedProxyGroupsById[group]).forEach((blockedGroup) => {
    fieldErrors.push(blockedProxyGroupsById[blockedGroup]);
  });
  return fieldErrors;
}
__name(validateProxyField, "validateProxyField");
function validateInputUsingValidator(validator, inputSchema, input, options = {}) {
  const isValid = validator(input);
  const { properties } = inputSchema;
  const required = inputSchema.required || [];
  let errors = [];
  if (!isValid) {
    errors = validator.errors.filter((error) => {
      if (error.keyword === "type" && error.instancePath) {
        const path = error.instancePath.replace(/^\//, "").split("/")[0];
        const propSchema = inputSchema.properties?.[path];
        const value = input[path];
        if (propSchema?.isSecret && typeof value === "string" && (propSchema.type === "object" || propSchema.type === "array") && (0, import_input_secrets.isEncryptedValueForFieldType)(value, propSchema.type)) {
          return false;
        }
      }
      return true;
    }).map((error) => parseAjvError(error, "input", properties, input)).filter((error) => !!error);
  }
  Object.keys(properties).forEach((property) => {
    const value = input[property];
    const { type, editor, patternKey, patternValue, isSecret } = properties[property];
    const fieldErrors = [];
    if (type === "object" && editor === "proxy") {
      const proxyValidationErrors = validateProxyField(property, value, required.includes(property), options.proxy);
      proxyValidationErrors.forEach((error) => {
        fieldErrors.push(error);
      });
    }
    if (type === "array" && value && Array.isArray(value)) {
      if (editor === "requestListSources") {
        const invalidIndexes = [];
        value.forEach((item, index) => {
          if (!item) invalidIndexes.push(index);
          else if (!item.url && !item.requestsFromUrl) invalidIndexes.push(index);
          else if (item.url && !import_consts.URL_REGEX.test(item.url)) invalidIndexes.push(index);
          else if (item.requestsFromUrl && !import_consts.URL_REGEX.test(item.requestsFromUrl)) invalidIndexes.push(index);
        });
        if (invalidIndexes.length) {
          fieldErrors.push(m("inputSchema.validation.requestListSourcesInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidIndexes: invalidIndexes.join(",")
          }));
        }
      }
      if (patternKey && editor === "keyValue") {
        const check = new RegExp(patternKey);
        const invalidIndexes = [];
        value.forEach((item, index) => {
          if (!check.test(item.key)) invalidIndexes.push(index);
        });
        if (invalidIndexes.length) {
          const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternKey`);
          fieldErrors.push(customError ?? m("inputSchema.validation.arrayKeysInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidIndexes: invalidIndexes.join(","),
            pattern: patternKey
          }));
        }
      }
      if (patternValue && editor === "keyValue") {
        const check = new RegExp(patternValue);
        const invalidIndexes = [];
        value.forEach((item, index) => {
          if (!check.test(item.value)) invalidIndexes.push(index);
        });
        if (invalidIndexes.length) {
          const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternValue`);
          fieldErrors.push(customError ?? m("inputSchema.validation.arrayValuesInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidIndexes: invalidIndexes.join(","),
            pattern: patternValue
          }));
        }
      } else if (patternValue && editor === "stringList") {
        const check = new RegExp(patternValue);
        const invalidIndexes = [];
        value.forEach((item, index) => {
          if (!check.test(item)) invalidIndexes.push(index);
        });
        if (invalidIndexes.length) {
          const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternValue`);
          fieldErrors.push(customError ?? m("inputSchema.validation.arrayValuesInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidIndexes: invalidIndexes.join(","),
            pattern: patternValue
          }));
        }
      }
    }
    if (type === "object" && value && typeof value === "object") {
      if (patternKey) {
        const check = new RegExp(patternKey);
        const invalidKeys = [];
        Object.keys(value).forEach((key) => {
          if (!check.test(key)) invalidKeys.push(key);
        });
        if (invalidKeys.length) {
          const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternKey`);
          fieldErrors.push(customError ?? m("inputSchema.validation.objectKeysInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidKeys: invalidKeys.join(","),
            pattern: patternKey
          }));
        }
      }
      if (patternValue) {
        const check = new RegExp(patternValue);
        const invalidKeys = [];
        Object.keys(value).forEach((key) => {
          const propertyValue = value[key];
          if (typeof propertyValue !== "string" || !check.test(propertyValue)) invalidKeys.push(key);
        });
        if (invalidKeys.length) {
          const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternValue`);
          fieldErrors.push(customError ?? m("inputSchema.validation.objectValuesInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidKeys: invalidKeys.join(","),
            pattern: patternValue
          }));
        }
      }
    }
    if (isSecret && value && typeof value === "string") {
      if ((0, import_input_secrets.isEncryptedValueForFieldType)(value, type) && !(0, import_input_secrets.isEncryptedValueForFieldSchema)(value, properties[property])) {
        fieldErrors.push(m("inputSchema.validation.secretFieldSchemaChanged", { fieldKey: property }));
      }
    }
    if (fieldErrors.length > 0) {
      const message = fieldErrors.join(", ");
      errors.push({ fieldKey: property, message });
    }
  });
  return errors;
}
__name(validateInputUsingValidator, "validateInputUsingValidator");
function makeInputJsFieldsReadable(json, jsFields, jsonSpacing = 4, globalSpacing = 0) {
  const parsedJson = JSON.parse(json);
  const replacements = {};
  jsFields.forEach((field) => {
    let maybeFunction = parsedJson[field];
    if (!maybeFunction || typeof maybeFunction !== "string") return;
    let ast;
    try {
      ast = (0, import_acorn_loose.parse)(maybeFunction, { ecmaVersion: "latest" });
    } catch {
      return;
    }
    const isMultiline = maybeFunction.includes("\n");
    const isSingleFunction = ast && ast.body.length === 1 && (ast.body[0].type === "FunctionDeclaration" || ast.body[0].type === "ExpressionStatement" && ast.body[0].expression.type === "ArrowFunctionExpression");
    if (!isSingleFunction && !isMultiline) return;
    const spaces = new Array(isSingleFunction ? jsonSpacing : jsonSpacing * 2).fill(" ").join("");
    maybeFunction = maybeFunction.split("\n").join(`
${spaces}`).trim();
    const replacementValue = isSingleFunction ? maybeFunction.replace(/[;]+$/g, "") : `\`${maybeFunction}\``;
    const replacementToken = `<<<REPLACEMENT_TOKEN:${Math.random()}>>>`;
    replacements[replacementToken] = replacementValue;
    parsedJson[field] = replacementToken;
  });
  let niceJson = JSON.stringify(parsedJson, null, jsonSpacing);
  Object.entries(replacements).forEach(([replacementToken, replacementValue]) => {
    niceJson = niceJson.replace(`"${replacementToken}"`, replacementValue);
  });
  const globalSpaces = new Array(globalSpacing).fill(" ").join("");
  niceJson = niceJson.split("\n").join(`
${globalSpaces}`);
  return niceJson;
}
__name(makeInputJsFieldsReadable, "makeInputJsFieldsReadable");
var DRAFT_2019_09_META_SCHEMA = "https://json-schema.org/draft/2019-09/schema";
function ensureAjvSupportsDraft2019(ajvInstance) {
  const metaSchema = ajvInstance.getSchema(DRAFT_2019_09_META_SCHEMA);
  if (!metaSchema) {
    throw new Error(
      `The provided Ajv instance does not support draft-2019-09 (missing meta-schema ${DRAFT_2019_09_META_SCHEMA}).`
    );
  }
}
__name(ensureAjvSupportsDraft2019, "ensureAjvSupportsDraft2019");
function validateRegexpPattern(pattern, fieldKey) {
  try {
    new RegExp(pattern);
  } catch {
    const message = m("inputSchema.validation.regexpNotValid", { pattern, fieldKey });
    throw new Error(`Input schema is not valid (${message})`);
  }
}
__name(validateRegexpPattern, "validateRegexpPattern");

// src/input_schema.ts
var { definitions } = import_json_schemas.inputSchema;
var [fieldDefinitions, subFieldDefinitions] = Object.values(definitions).reduce((acc, definition) => {
  if (definition.title.startsWith("Utils:")) {
    return acc;
  }
  if (definition.title.startsWith("Sub-schema:")) {
    acc[1].push(definition);
  } else {
    acc[0].push(definition);
  }
  return acc;
}, [[], []]);
function getCustomErrorMessage(rootSchema, schemaPath) {
  if (!schemaPath) return null;
  const pathParts = schemaPath.replace(/^#\//, "").split("/").filter(Boolean);
  const keyword = pathParts.pop();
  if (!keyword) return null;
  let schemaFragment = rootSchema;
  for (const key of pathParts) {
    if (schemaFragment && typeof schemaFragment === "object") {
      schemaFragment = schemaFragment[key];
    } else {
      return null;
    }
  }
  if (typeof schemaFragment !== "object") {
    return null;
  }
  const { errorMessage } = schemaFragment;
  if (!errorMessage) return null;
  if (typeof errorMessage === "object" && keyword in errorMessage) {
    return errorMessage[keyword];
  }
  return null;
}
__name(getCustomErrorMessage, "getCustomErrorMessage");
function parseAjvError(error, rootName, properties = {}, input = {}) {
  let fieldKey;
  let message;
  const cleanPropertyName = /* @__PURE__ */ __name((name) => {
    return name.replace(/^\/|\/$/g, "").replace(/\//g, ".");
  }, "cleanPropertyName");
  const customError = getCustomErrorMessage({ properties }, error.schemaPath);
  if (customError) {
    fieldKey = cleanPropertyName(error.instancePath);
    return { fieldKey, message: customError };
  }
  if (error.keyword === "type") {
    fieldKey = cleanPropertyName(error.instancePath);
    if (properties[fieldKey] && properties[fieldKey].nullable && input[fieldKey] === null) {
      return null;
    }
    message = m("inputSchema.validation.generic", { rootName, fieldKey, message: error.message });
  } else if (error.keyword === "required") {
    fieldKey = cleanPropertyName(`${error.instancePath}/${error.params.missingProperty}`);
    message = m("inputSchema.validation.required", { rootName, fieldKey });
  } else if (error.keyword === "additionalProperties") {
    fieldKey = cleanPropertyName(`${error.instancePath}/${error.params.additionalProperty}`);
    message = m("inputSchema.validation.additionalProperty", { rootName, fieldKey });
  } else if (error.keyword === "unevaluatedProperties") {
    fieldKey = cleanPropertyName(`${error.instancePath}/${error.params.unevaluatedProperty}`);
    message = m("inputSchema.validation.additionalProperty", { rootName, fieldKey });
  } else if (error.keyword === "enum") {
    fieldKey = cleanPropertyName(error.instancePath);
    const errorMessage = `${error.message}: "${error.params.allowedValues.join('", "')}"`;
    message = m("inputSchema.validation.generic", { rootName, fieldKey, message: errorMessage });
  } else if (error.keyword === "const") {
    fieldKey = cleanPropertyName(error.instancePath);
    message = m("inputSchema.validation.generic", { rootName, fieldKey, message: error.message });
  } else {
    fieldKey = cleanPropertyName(error.instancePath);
    message = m("inputSchema.validation.generic", { rootName, fieldKey, message: error.message });
  }
  return { fieldKey, message };
}
__name(parseAjvError, "parseAjvError");
var validateAgainstSchemaOrThrow = /* @__PURE__ */ __name((validator, obj, inputSchema, rootName) => {
  if (validator.validate(inputSchema, obj)) return;
  const errorMessage = parseAjvError(validator.errors[0], rootName)?.message;
  throw new Error(`Input schema is not valid (${errorMessage})`);
}, "validateAgainstSchemaOrThrow");
function validateBasicStructure(validator, obj) {
  const { $id, ...schemaWithoutId } = import_json_schemas.inputSchema;
  const schemaWithoutProperties = {
    ...schemaWithoutId,
    properties: { ...import_json_schemas.inputSchema.properties, properties: { type: "object" } }
  };
  validateAgainstSchemaOrThrow(validator, obj, schemaWithoutProperties, "schema");
}
__name(validateBasicStructure, "validateBasicStructure");
function validateFieldAgainstSchemaDefinition(validator, fieldSchema, fieldKey, isSubField = false) {
  const relevantDefinitions = isSubField ? subFieldDefinitions : fieldDefinitions;
  const matchingDefinitions = Object.values(relevantDefinitions).filter((definition2) => {
    return definition2.properties.type.enum ? definition2.properties.type.enum[0] === fieldSchema.type : Array.isArray(fieldSchema.type);
  });
  if (matchingDefinitions.length === 0) {
    const errorMessage = m("inputSchema.validation.noMatchingDefinition", { fieldKey });
    throw new Error(`Input schema is not valid (${errorMessage})`);
  }
  const enhanceDefinition = /* @__PURE__ */ __name((definition2) => {
    return {
      ...definition2,
      definitions
    };
  }, "enhanceDefinition");
  if (matchingDefinitions.length === 1) {
    validateAgainstSchemaOrThrow(validator, fieldSchema, enhanceDefinition(matchingDefinitions[0]), `schema.properties.${fieldKey}`);
    return;
  }
  if (fieldSchema.enum) {
    const definition2 = matchingDefinitions.filter((item) => !!item.properties.enum).pop();
    if (!definition2) throw new Error('Input schema validation failed to find "enum property" definition');
    validateAgainstSchemaOrThrow(validator, fieldSchema, enhanceDefinition(definition2), `schema.properties.${fieldKey}`);
    return;
  }
  if (fieldSchema.resourceType) {
    const definition2 = matchingDefinitions.filter((item) => !!item.properties.resourceType).pop();
    if (!definition2) throw new Error('Input schema validation failed to find "resource property" definition');
    validateAgainstSchemaOrThrow(validator, fieldSchema, enhanceDefinition(definition2), `schema.properties.${fieldKey}`);
    return;
  }
  const definition = matchingDefinitions.filter((item) => !item.properties.enum && !item.properties.resourceType).pop();
  if (!definition) throw new Error('Input schema validation failed to find other than "enum property" definition');
  validateAgainstSchemaOrThrow(validator, fieldSchema, enhanceDefinition(definition), `schema.properties.${fieldKey}`);
}
__name(validateFieldAgainstSchemaDefinition, "validateFieldAgainstSchemaDefinition");
function validateField(validator, fieldSchema, fieldKey, isSubField = false) {
  validateFieldAgainstSchemaDefinition(validator, fieldSchema, fieldKey, isSubField);
  const { pattern } = fieldSchema;
  const { patternKey, patternValue } = fieldSchema;
  if (pattern) validateRegexpPattern(pattern, `${fieldKey}.pattern`);
  if (patternKey) validateRegexpPattern(patternKey, `${fieldKey}.patternKey`);
  if (patternValue) validateRegexpPattern(patternValue, `${fieldKey}.patternValue`);
}
__name(validateField, "validateField");
function validateSubFields(validator, fieldSchema, fieldKey) {
  Object.entries(fieldSchema.properties).forEach(([subFieldKey, subFieldSchema]) => {
    if (subFieldSchema.type === "object" && subFieldSchema.properties) {
      validateSubFields(validator, subFieldSchema, `${fieldKey}.${subFieldKey}`);
    }
    if (subFieldSchema.type === "array" && subFieldSchema.items) {
      validateArrayField(validator, subFieldSchema, `${fieldKey}.${subFieldKey}`);
    }
    validateField(validator, subFieldSchema, `${fieldKey}.${subFieldKey}`, true);
  });
}
__name(validateSubFields, "validateSubFields");
function validateArrayField(validator, fieldSchema, fieldKey) {
  const arraySchema = fieldSchema.items;
  if (!arraySchema) return;
  if (arraySchema.type === "object" && arraySchema.properties) {
    validateSubFields(validator, arraySchema, `${fieldKey}.items`);
  }
  if (arraySchema.type === "array" && arraySchema.items) {
    validateArrayField(validator, arraySchema, `${fieldKey}.items`);
  }
}
__name(validateArrayField, "validateArrayField");
function validateProperties(inputSchema, validator) {
  Object.entries(inputSchema.properties).forEach(([fieldKey, fieldSchema]) => {
    if (fieldSchema.type === "object" && fieldSchema.properties) {
      validateSubFields(validator, fieldSchema, fieldKey);
    }
    if (fieldSchema.type === "array" && fieldSchema.items) {
      validateArrayField(validator, fieldSchema, fieldKey);
    }
    validateField(validator, fieldSchema, fieldKey);
  });
}
__name(validateProperties, "validateProperties");
function validateExistenceOfRequiredFields(inputSchema) {
  if (!inputSchema?.required?.length) return;
  Object.values(inputSchema?.required).forEach((fieldKey) => {
    if (inputSchema?.properties[fieldKey]) return;
    throw new Error(m("inputSchema.validation.missingRequiredField", { fieldKey }));
  });
}
__name(validateExistenceOfRequiredFields, "validateExistenceOfRequiredFields");
function validateInputSchema(validator, inputSchema) {
  ensureAjvSupportsDraft2019(validator);
  validateBasicStructure(validator, inputSchema);
  validateProperties(inputSchema, validator);
  validateExistenceOfRequiredFields(inputSchema);
  validateAgainstSchemaOrThrow(validator, inputSchema, import_json_schemas.inputSchema, "schema");
}
__name(validateInputSchema, "validateInputSchema");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ensureAjvSupportsDraft2019,
  getCustomErrorMessage,
  inputSchema,
  m,
  makeInputJsFieldsReadable,
  parseAjvError,
  validateExistenceOfRequiredFields,
  validateInputSchema,
  validateInputUsingValidator,
  validateRegexpPattern
});
//# sourceMappingURL=index.cjs.map