{"version":3,"sources":["../../src/intl.ts","../../src/input_schema.ts","../../src/utilities.ts"],"sourcesContent":["const intlStrings = {\n    'inputSchema.validation.generic':\n        'Field {rootName}.{fieldKey} {message}',\n    'inputSchema.validation.required':\n        'Field {rootName}.{fieldKey} is required',\n    'inputSchema.validation.proxyRequired':\n        'Field {rootName}.{fieldKey} is required. Please provide custom proxy URLs or use Apify Proxy.',\n    'inputSchema.validation.requestListSourcesInvalid':\n        'Items in {rootName}.{fieldKey} at positions [{invalidIndexes}] do not contain valid URLs',\n    'inputSchema.validation.arrayKeysInvalid':\n        'Keys in {rootName}.{fieldKey} at positions [{invalidIndexes}] must match regular expression \"{pattern}\"',\n    'inputSchema.validation.arrayValuesInvalid':\n        'Values in {rootName}.{fieldKey} at positions [{invalidIndexes}] must match regular expression \"{pattern}\"',\n    'inputSchema.validation.objectKeysInvalid':\n        'Keys [{invalidKeys}] in {rootName}.{fieldKey} must match regular expression \"{pattern}',\n    'inputSchema.validation.objectValuesInvalid':\n        'Keys [{invalidKeys}] in {rootName}.{fieldKey} must have string value which matches regular expression \"{pattern}\"',\n    'inputSchema.validation.additionalProperty':\n        'Property {rootName}.{fieldKey} is not allowed.',\n    'inputSchema.validation.proxyGroupsNotAvailable':\n        'You currently do not have access to proxy groups: {groups}',\n    'inputSchema.validation.customProxyInvalid':\n        'Proxy URL \"{invalidUrl}\" has invalid format, it must be socks[4|4a|5|5h]|http[s]://[username[:password]]@hostname:port.',\n    'inputSchema.validation.apifyProxyCountryInvalid':\n        'Country code \"{invalidCountry}\" is invalid. Only ISO 3166-1 alpha-2 country codes are supported.',\n    'inputSchema.validation.apifyProxyCountryWithoutApifyProxyForbidden':\n        'The country for Apify Proxy can be specified only when using Apify Proxy.',\n    'inputSchema.validation.noAvailableAutoProxy':\n        'Currently you do not have access to any proxy group usable in automatic mode.',\n    'inputSchema.validation.noMatchingDefinition':\n        'Field schema.properties.{fieldKey} is not matching any input schema type definition. Please make sure that it\\'s type is valid.',\n    'inputSchema.validation.missingRequiredField':\n        'Field schema.properties.{fieldKey} does not exist, but it is specified in schema.required. Either define the field or remove it from schema.required.',\n    'inputSchema.validation.proxyGroupMustBeArrayOfStrings':\n        'Field {rootName}.{fieldKey}.apifyProxyGroups must be an array of strings.',\n    'inputSchema.validation.secretFieldSchemaChanged':\n        'The field schema.properties.{fieldKey} is a secret field, but its schema has changed. Please update the value in the input editor.',\n    'inputSchema.validation.regexpNotValid':\n        'The regular expression \"{pattern}\" in field schema.properties.{fieldKey} must be valid.',\n    'inputSchema.validation.regexpNotSafe':\n        'The regular expression \"{pattern}\" in field schema.properties.{fieldKey} may cause excessive backtracking or be unsafe to execute.',\n};\n\n/**\n * Helper function to simulate intl formatMessage function\n */\nexport function m(stringId: string, variables?: Record<string, any>) {\n    let text = intlStrings[stringId as keyof typeof intlStrings];\n    if (!text) return stringId;\n\n    if (variables) {\n        Object.keys(variables).forEach((variableName) => {\n            text = text.split(`{${variableName}}`).join(variables[variableName]);\n        });\n    }\n\n    return text;\n}\n","import type { ErrorObject, Schema } from 'ajv';\nimport type Ajv from 'ajv';\n\nimport { inputSchema as schema } from '@apify/json_schemas';\n\nimport { m } from './intl';\nimport type {\n    ArrayFieldDefinition,\n    CommonResourceFieldDefinition,\n    FieldDefinition,\n    InputSchema,\n    InputSchemaBaseChecked,\n    ObjectFieldDefinition,\n    StringFieldDefinition,\n} from './types';\nimport { ensureAjvSupportsDraft2019, validateRegexpPattern } from './utilities';\n\nexport { schema as inputSchema };\n\nconst { definitions } = schema;\n\n// Because the definitions contain not only the root properties definitions, but also sub-schema definitions\n// and utility definitions, we need to filter them out and validate only against the appropriate ones.\n// We do this by checking the prefix of the definition title (Utils: or Sub-schema:)\n\nconst [fieldDefinitions, subFieldDefinitions] = Object\n    .values<any>(definitions)\n    .reduce<[any[], any[]]>((acc, definition) => {\n        if (definition.title.startsWith('Utils:')) {\n            // skip utility definitions\n            return acc;\n        }\n\n        if (definition.title.startsWith('Sub-schema:')) {\n            acc[1].push(definition);\n        } else {\n            acc[0].push(definition);\n        }\n\n        return acc;\n    }, [[], []]);\n\n/**\n * Retrieves a custom error message defined in the schema for a particular schema path.\n * @param rootSchema json schema object\n * @param schemaPath schema path to the failed validation keyword,\n *  as provided in an AJV error object, including the keyword at the end, e.g. \"#/properties/name/type\"\n */\nexport function getCustomErrorMessage(rootSchema: Record<string, any>, schemaPath: string): string | null {\n    if (!schemaPath) return null;\n\n    const pathParts = schemaPath\n        .replace(/^#\\//, '')\n        .split('/')\n        .filter(Boolean);\n\n    // The last part is the keyword\n    const keyword = pathParts.pop();\n    if (!keyword) return null;\n\n    // Navigate through the schema to find the relevant fragment\n    let schemaFragment: Record<string, any> = rootSchema;\n    for (const key of pathParts) {\n        if (schemaFragment && typeof schemaFragment === 'object') {\n            schemaFragment = schemaFragment[key];\n        } else {\n            return null;\n        }\n    }\n\n    if (typeof schemaFragment !== 'object') {\n        return null;\n    }\n\n    const { errorMessage } = schemaFragment;\n    if (!errorMessage) return null;\n\n    if (typeof errorMessage === 'object' && keyword in errorMessage) {\n        return errorMessage[keyword];\n    }\n\n    return null;\n}\n\n/**\n * This function parses AJV error and transforms it into a readable string.\n *\n * @param error An error as returned from AJV.\n * @param rootName Usually 'input' or 'schema' based on if we are passing the input or schema.\n * @param properties (Used only when parsing input errors) List of input schema properties.\n * @param input (Used only when parsing input errors) Actual input that is being parsed.\n * @returns {null|{fieldKey: *, message: *}}\n */\nexport function parseAjvError(\n    error: ErrorObject,\n    rootName: string,\n    properties: Record<string, { nullable?: boolean, editor?: string }> = {},\n    input: Record<string, unknown> = {},\n): { fieldKey: string; message: string } | null {\n    // There are 3 possible errors comming from validation:\n    // - either { keword: 'anything', instancePath: '/someField', message: 'error message that we can use' }\n    // - or { keyword: 'additionalProperties', params: { additionalProperty: 'field' }, message: 'must NOT have additional properties' }\n    // - or { keyword: 'required', instancePath: '', params.missingProperty: 'someField' }\n\n    let fieldKey: string;\n    let message: string;\n\n    // remove leading and trailing slashes and replace remaining slashes with dots\n    const cleanPropertyName = (name: string) => {\n        return name.replace(/^\\/|\\/$/g, '').replace(/\\//g, '.');\n    };\n\n    // First, try to get a custom error message from the schema\n    // If found, use it directly and skip further processing\n    const customError = getCustomErrorMessage({ properties }, error.schemaPath);\n    if (customError) {\n        fieldKey = cleanPropertyName(error.instancePath);\n        return { fieldKey, message: customError };\n    }\n\n    // If error is with keyword type, it means that type of input is incorrect\n    // this can mean that provided value is null\n    if (error.keyword === 'type') {\n        fieldKey = cleanPropertyName(error.instancePath);\n        // Check if value is null and field is nullable, if yes, then skip this error\n        if (properties[fieldKey] && properties[fieldKey].nullable && input[fieldKey] === null) {\n            return null;\n        }\n        message = m('inputSchema.validation.generic', { rootName, fieldKey, message: error.message });\n    } else if (error.keyword === 'required') {\n        fieldKey = cleanPropertyName(`${error.instancePath}/${error.params.missingProperty}`);\n        message = m('inputSchema.validation.required', { rootName, fieldKey });\n    } else if (error.keyword === 'additionalProperties') {\n        fieldKey = cleanPropertyName(`${error.instancePath}/${error.params.additionalProperty}`);\n        message = m('inputSchema.validation.additionalProperty', { rootName, fieldKey });\n    } else if (error.keyword === 'unevaluatedProperties') {\n        fieldKey = cleanPropertyName(`${error.instancePath}/${error.params.unevaluatedProperty}`);\n        message = m('inputSchema.validation.additionalProperty', { rootName, fieldKey });\n    } else if (error.keyword === 'enum') {\n        fieldKey = cleanPropertyName(error.instancePath);\n        const errorMessage = `${error.message}: \"${error.params.allowedValues.join('\", \"')}\"`;\n        message = m('inputSchema.validation.generic', { rootName, fieldKey, message: errorMessage });\n    } else if (error.keyword === 'const') {\n        fieldKey = cleanPropertyName(error.instancePath);\n        message = m('inputSchema.validation.generic', { rootName, fieldKey, message: error.message });\n    } else {\n        fieldKey = cleanPropertyName(error.instancePath);\n        message = m('inputSchema.validation.generic', { rootName, fieldKey, message: error.message });\n    }\n\n    return { fieldKey, message };\n}\n\n/**\n * Validates given object against schema and throws a human-readable error.\n */\nconst validateAgainstSchemaOrThrow = (validator: Ajv, obj: Record<string, unknown>, inputSchema: Schema, rootName: string) => {\n    if (validator.validate(inputSchema, obj)) return;\n\n    const errorMessage = parseAjvError(validator.errors![0], rootName)?.message;\n    throw new Error(`Input schema is not valid (${errorMessage})`);\n};\n\n/**\n * This validates given object only against the basic input schema without checking the particular fields.\n * We override schema.properties.properties not to validate field definitions.\n */\nfunction validateBasicStructure(validator: Ajv, obj: Record<string, unknown>): asserts obj is InputSchemaBaseChecked {\n    // We need to remove $id from the schema, because AJV cache the schema by id and if we provide\n    // different schema instance with the same id, it will throw an error.\n    const { $id, ...schemaWithoutId } = schema;\n    const schemaWithoutProperties = {\n        ...schemaWithoutId,\n        properties: { ...schema.properties, properties: { type: 'object' } as any },\n    };\n    validateAgainstSchemaOrThrow(validator, obj, schemaWithoutProperties, 'schema');\n}\n\n/**\n * Validates particular field against it's schema.\n * @param validator An instance of AJV validator (must support draft 2019-09).\n * @param fieldSchema Schema of the field to validate.\n * @param fieldKey Key of the field in the input schema.\n * @param isSubField If true, the field is a sub-field of another field, so we need to skip some definitions.\n */\nfunction validateFieldAgainstSchemaDefinition(\n    validator: Ajv,\n    fieldSchema: Record<string, unknown>,\n    fieldKey: string,\n    isSubField = false,\n): asserts fieldSchema is FieldDefinition {\n    const relevantDefinitions = isSubField ? subFieldDefinitions : fieldDefinitions;\n\n    const matchingDefinitions = Object\n        .values<any>(relevantDefinitions) // cast as any, as the code in first branch seems to be invalid\n        .filter((definition) => {\n            return definition.properties.type.enum\n                // This is a normal case where fieldSchema.type can be only one possible value matching definition.properties.type.enum.0\n                ? definition.properties.type.enum[0] === fieldSchema.type\n                // This is a type \"Any\" where fieldSchema.type is an array of possible values\n                : Array.isArray(fieldSchema.type);\n        });\n\n    // There is not matching definition.\n    if (matchingDefinitions.length === 0) {\n        const errorMessage = m('inputSchema.validation.noMatchingDefinition', { fieldKey });\n        throw new Error(`Input schema is not valid (${errorMessage})`);\n    }\n\n    // We are validating a field schema against one of the definitions, but one definition can reference other definitions.\n    // So this basically creates a new JSON Schema with a picked definition at root and puts all definitions from the `schema.json`\n    // into the `definitions` property of this final schema.\n    const enhanceDefinition = (definition: object) => {\n        return {\n            ...definition,\n            definitions,\n        };\n    };\n\n    // If there is only one matching then we are done and simply compare it.\n    if (matchingDefinitions.length === 1) {\n        validateAgainstSchemaOrThrow(validator, fieldSchema, enhanceDefinition(matchingDefinitions[0]), `schema.properties.${fieldKey}`);\n        return;\n    }\n\n    // If there are more matching definitions then we need to get the right one.\n    // If the definition contains \"enum\" property then it's enum type.\n    if ((fieldSchema as StringFieldDefinition).enum) {\n        const definition = matchingDefinitions.filter((item) => !!item.properties.enum).pop();\n        if (!definition) throw new Error('Input schema validation failed to find \"enum property\" definition');\n        validateAgainstSchemaOrThrow(validator, fieldSchema, enhanceDefinition(definition), `schema.properties.${fieldKey}`);\n        return;\n    }\n    // If the definition contains \"resourceType\" property then it's resource type.\n    if ((fieldSchema as CommonResourceFieldDefinition<unknown>).resourceType) {\n        const definition = matchingDefinitions.filter((item) => !!item.properties.resourceType).pop();\n        if (!definition) throw new Error('Input schema validation failed to find \"resource property\" definition');\n        validateAgainstSchemaOrThrow(validator, fieldSchema, enhanceDefinition(definition), `schema.properties.${fieldKey}`);\n        return;\n    }\n    // Otherwise we use the other definition.\n    const definition = matchingDefinitions.filter((item) => !item.properties.enum && !item.properties.resourceType).pop();\n    if (!definition) throw new Error('Input schema validation failed to find other than \"enum property\" definition');\n\n    validateAgainstSchemaOrThrow(validator, fieldSchema, enhanceDefinition(definition), `schema.properties.${fieldKey}`);\n}\n\n/**\n * Validates particular field against it's schema and other rules (like regex patterns).\n * @param validator An instance of AJV validator (must support draft 2019-09).\n * @param fieldSchema Schema of the field to validate.\n * @param fieldKey Key of the field in the input schema.\n * @param isSubField If true, the field is a sub-field of another field, so we need to skip some definitions.\n */\nfunction validateField(validator: Ajv, fieldSchema: Record<string, unknown>, fieldKey: string, isSubField = false): asserts fieldSchema is FieldDefinition {\n    // Validate against schema definition first.\n    validateFieldAgainstSchemaDefinition(validator, fieldSchema, fieldKey, isSubField);\n\n    // Validate regex patterns if defined.\n    const { pattern } = fieldSchema as Partial<StringFieldDefinition>;\n    const { patternKey, patternValue } = fieldSchema as Partial<ObjectFieldDefinition & ArrayFieldDefinition>;\n\n    if (pattern) validateRegexpPattern(pattern, `${fieldKey}.pattern`);\n    if (patternKey) validateRegexpPattern(patternKey, `${fieldKey}.patternKey`);\n    if (patternValue) validateRegexpPattern(patternValue, `${fieldKey}.patternValue`);\n}\n\n/**\n * Validates all subfields (and their subfields) of a given field schema.\n */\nfunction validateSubFields(validator: Ajv, fieldSchema: InputSchemaBaseChecked, fieldKey: string) {\n    Object.entries(fieldSchema.properties).forEach(([subFieldKey, subFieldSchema]) => {\n        // The sub-properties has to be validated first, so we got more relevant error messages.\n        if (subFieldSchema.type === 'object' && subFieldSchema.properties) {\n            // If the field has sub-fields, we need to validate them as well.\n            validateSubFields(validator, subFieldSchema as any as InputSchemaBaseChecked, `${fieldKey}.${subFieldKey}`);\n        }\n\n        // If the field is an array and has defined schema (items property), we need to validate it differently.\n        if (subFieldSchema.type === 'array' && subFieldSchema.items) {\n            validateArrayField(validator, subFieldSchema, `${fieldKey}.${subFieldKey}`);\n        }\n\n        validateField(validator, subFieldSchema, `${fieldKey}.${subFieldKey}`, true);\n    });\n}\n\nfunction validateArrayField(validator: Ajv, fieldSchema: { items?: { type: 'string', properties: Record<string, any> }}, fieldKey: string) {\n    const arraySchema = (fieldSchema as any).items;\n    if (!arraySchema) return;\n\n    // If the array has object items and have sub-schema defined, we need to validate it.\n    if (arraySchema.type === 'object' && arraySchema.properties) {\n        validateSubFields(validator, arraySchema as InputSchemaBaseChecked, `${fieldKey}.items`);\n    }\n\n    // If it's an array of arrays we need, we need to validate the inner array schema.\n    if (arraySchema.type === 'array' && arraySchema.items) {\n        validateArrayField(validator, arraySchema, `${fieldKey}.items`);\n    }\n}\n\n/**\n * Validates all properties in the input schema\n */\nfunction validateProperties(inputSchema: InputSchemaBaseChecked, validator: Ajv): asserts inputSchema is InputSchema {\n    Object.entries(inputSchema.properties).forEach(([fieldKey, fieldSchema]) => {\n        // The sub-properties has to be validated first, so we got more relevant error messages.\n        if (fieldSchema.type === 'object' && fieldSchema.properties) {\n            // If the field has sub-fields, we need to validate them as well.\n            validateSubFields(validator, fieldSchema as any as InputSchemaBaseChecked, fieldKey);\n        }\n\n        // If the field is an array and has defined schema (items property), we need to validate it differently.\n        if (fieldSchema.type === 'array' && fieldSchema.items) {\n            validateArrayField(validator, fieldSchema, fieldKey);\n        }\n\n        validateField(validator, fieldSchema, fieldKey);\n    });\n}\n\n/**\n * Validates that all required fields are present in properties list\n */\nexport function validateExistenceOfRequiredFields(inputSchema: InputSchema) {\n    // If the input schema does not have any required fields, we do not need to validate them\n    if (!inputSchema?.required?.length) return;\n\n    Object.values(inputSchema?.required).forEach((fieldKey) => {\n        // If the required field is present in the list of properties, we can check the next one\n        if (inputSchema?.properties[fieldKey as string]) return;\n\n        // The required field is not defined in list of properties. Which means the schema is not valid.\n        throw new Error(m('inputSchema.validation.missingRequiredField', { fieldKey }));\n    });\n}\n\n/**\n * This function validates given input schema first just for basic structure then each field one by one,\n * then checks that all required fields are present and finally checks fully against the whole schema.\n *\n * This way we get the most accurate error message for user.\n *\n * @param validator An instance of AJV validator. Important: The JSON Schema that the passed input schema is validated against\n *  is using features from JSON Schema 2019 draft, so the AJV instance must support it.\n * @param inputSchema Input schema to validate.\n */\nexport function validateInputSchema(validator: Ajv, inputSchema: Record<string, unknown>): asserts inputSchema is InputSchema {\n    ensureAjvSupportsDraft2019(validator);\n\n    // First validate just basic structure without fields.\n    validateBasicStructure(validator, inputSchema);\n\n    // Then validate each field separately.\n    validateProperties(inputSchema, validator);\n\n    // Next validate if required fields are actually present in the schema\n    validateExistenceOfRequiredFields(inputSchema);\n\n    // Finally just to be sure run validation against the whole schema.\n    validateAgainstSchemaOrThrow(validator, inputSchema, schema, 'schema');\n}\n","import { parse } from 'acorn-loose';\nimport type { ValidateFunction } from 'ajv';\nimport type Ajv from 'ajv/dist/2019';\nimport { countries } from 'countries-list';\n\nimport { PROXY_URL_REGEX, URL_REGEX } from '@apify/consts';\nimport { isEncryptedValueForFieldSchema, isEncryptedValueForFieldType } from '@apify/input_secrets';\n\nimport { getCustomErrorMessage, parseAjvError } from './input_schema';\nimport { m } from './intl';\n\n/**\n * Validates input field configured with proxy editor\n * @param fieldKey Proxy field value\n * @param value Proxy field value\n * @param [isRequired] Whether the field is required or not\n * @param [options] Information about proxy groups availability\n * @param [options.hasAutoProxyGroups] Informs validation whether user has atleast one proxy group available in auto mode\n * @param [options.availableProxyGroups] List of available proxy groups\n * @param [options.disabledProxyGroups] Object with groupId as key and error message as value (mostly for residential/SERP)\n */\nfunction validateProxyField(\n    fieldKey: Record<string, unknown>,\n    value: Record<string, any>,\n    isRequired = false,\n    options: { hasAutoProxyGroups?: boolean; availableProxyGroups?: string[]; disabledProxyGroups?: Record<string, unknown> } | null = null,\n) {\n    const fieldErrors: any[] = [];\n    if (isRequired) {\n        // Nullable error is already handled by AJV\n        if (value === null) return fieldErrors;\n        if (!value) {\n            const message = m('inputSchema.validation.required', { rootName: 'input', fieldKey });\n            fieldErrors.push(message);\n            return fieldErrors;\n        }\n\n        const { useApifyProxy, proxyUrls } = value;\n        if (!useApifyProxy && (!Array.isArray(proxyUrls) || proxyUrls.length === 0)) {\n            fieldErrors.push(m('inputSchema.validation.proxyRequired', { rootName: 'input', fieldKey }));\n            return fieldErrors;\n        }\n    }\n\n    // Input is not required, so missing value is valid\n    if (!value) return fieldErrors;\n\n    const { useApifyProxy, proxyUrls, apifyProxyGroups, apifyProxyCountry } = value;\n\n    if (!useApifyProxy && Array.isArray(proxyUrls)) {\n        let invalidUrl = false;\n        proxyUrls.forEach((url) => {\n            if (!PROXY_URL_REGEX.test(url.trim())) invalidUrl = url.trim();\n        });\n        if (invalidUrl) {\n            fieldErrors.push(m('inputSchema.validation.customProxyInvalid', { invalidUrl }));\n        }\n    }\n\n    // Apify proxy country can be set only when using Apify proxy\n    if (!useApifyProxy && apifyProxyCountry) {\n        fieldErrors.push(m('inputSchema.validation.apifyProxyCountryWithoutApifyProxyForbidden'));\n    }\n\n    // If Apify proxy is not used skip additional checks\n    if (!useApifyProxy) return fieldErrors;\n\n    // If Apify proxy is used, check if there is a selected country and if so, check that it's valid (empty or a valid country code)\n    if (apifyProxyCountry && !countries[apifyProxyCountry as keyof typeof countries]) {\n        fieldErrors.push(m('inputSchema.validation.apifyProxyCountryInvalid', { invalidCountry: apifyProxyCountry }));\n    }\n\n    // If options are not provided skip additional checks\n    if (!options) return fieldErrors;\n\n    // if apifyProxyGroups exists it must be an array of strings\n    const isStringsArray = (array: string[]) => array.every((item) => typeof item === 'string');\n    if (apifyProxyGroups && !(Array.isArray(apifyProxyGroups) && isStringsArray(apifyProxyGroups))) {\n        fieldErrors.push(m('inputSchema.validation.proxyGroupMustBeArrayOfStrings', { rootName: 'input', fieldKey }));\n        return fieldErrors;\n    }\n\n    const selectedProxyGroups = (apifyProxyGroups || []);\n\n    // Auto mode, check that user has access to alteast one proxy group usable in this mode\n    if (!selectedProxyGroups.length && !options.hasAutoProxyGroups) {\n        fieldErrors.push(m('inputSchema.validation.noAvailableAutoProxy'));\n        return fieldErrors;\n    }\n\n    // Check if proxy groups selected by user are available to him\n    const availableProxyGroupsById = {} as Record<string, boolean>;\n    (options.availableProxyGroups || []).forEach((group) => { availableProxyGroupsById[group] = true; });\n    const unavailableProxyGroups = selectedProxyGroups.filter((group: string) => !availableProxyGroupsById[group]);\n\n    if (unavailableProxyGroups.length) {\n        fieldErrors.push(m('inputSchema.validation.proxyGroupsNotAvailable', {\n            rootName: 'input',\n            fieldKey,\n            groups: unavailableProxyGroups.join(', '),\n        }));\n    }\n\n    // Check if any of the proxy groups are blocked and if yes then output the associated message\n    const blockedProxyGroupsById = options.disabledProxyGroups || {};\n    selectedProxyGroups\n        .filter((group: string) => blockedProxyGroupsById[group])\n        .forEach((blockedGroup: string) => {\n            fieldErrors.push(blockedProxyGroupsById[blockedGroup]);\n        });\n\n    return fieldErrors;\n}\n\n/**\n * Uses AJV validator to validate input with input schema and then\n * does custom validation for our own properties (nullable, patternKey, patternValue)\n * @param validator Initialized AJV validator\n * @param inputSchema Valid input schema in object\n * @param input Input object to be validated\n * @param options (Optional) Additional validation configuration for certain fields\n */\nexport function validateInputUsingValidator(\n    validator: ValidateFunction,\n    inputSchema: Record<string, any>,\n    input: Record<string, unknown>,\n    options: Record<string, any> = {},\n) {\n    const isValid = validator(input); // Check if input is valid based on schema values\n\n    const { properties } = inputSchema;\n    const required = inputSchema.required || [];\n\n    let errors: { fieldKey: string, message: string }[] = [];\n    // Process AJV validation errors\n    if (!isValid) {\n        errors = validator.errors!\n            .filter((error) => {\n                // We are storing encrypted objects/arrays as strings, so AJV will throw type the error here.\n                // So we need to skip these errors.\n                if (error.keyword === 'type' && error.instancePath) {\n                    const path = error.instancePath.replace(/^\\//, '').split('/')[0];\n                    const propSchema = inputSchema.properties?.[path];\n                    const value = input[path];\n\n                    // Check if the property is a secret and if the value is an encrypted value.\n                    // We do additional validation of the field schema in the later part of this function\n                    if (\n                        propSchema?.isSecret\n                        && typeof value === 'string'\n                        && (propSchema.type === 'object' || propSchema.type === 'array')\n                        && isEncryptedValueForFieldType(value, propSchema.type)\n                    ) {\n                        return false;\n                    }\n                }\n                return true;\n            })\n            .map((error) => parseAjvError(error, 'input', properties, input))\n            .filter((error) => !!error) as any[];\n    }\n\n    Object.keys(properties).forEach((property) => {\n        const value = input[property];\n        const { type, editor, patternKey, patternValue, isSecret } = properties[property];\n        const fieldErrors = [];\n        // Check that proxy is required, if yes, valides that it's correctly setup\n        if (type === 'object' && editor === 'proxy') {\n            const proxyValidationErrors = validateProxyField(property as any, value as Record<string, any>, required.includes(property), options.proxy);\n            proxyValidationErrors.forEach((error) => {\n                fieldErrors.push(error);\n            });\n        }\n        // Check that array items fit patternKey and patternValue\n        if (type === 'array' && value && Array.isArray(value)) {\n            if (editor === 'requestListSources') {\n                const invalidIndexes: any[] = [];\n                value.forEach((item, index) => {\n                    if (!item) invalidIndexes.push(index);\n                    else if (!item.url && !item.requestsFromUrl) invalidIndexes.push(index);\n                    else if (item.url && !URL_REGEX.test(item.url)) invalidIndexes.push(index);\n                    else if (item.requestsFromUrl && !URL_REGEX.test(item.requestsFromUrl)) invalidIndexes.push(index);\n                });\n                if (invalidIndexes.length) {\n                    fieldErrors.push(m('inputSchema.validation.requestListSourcesInvalid', {\n                        rootName: 'input',\n                        fieldKey: property,\n                        invalidIndexes: invalidIndexes.join(','),\n                    }));\n                }\n            }\n            // If patternKey is provided, then validate keys of objects in array\n            if (patternKey && editor === 'keyValue') {\n                const check = new RegExp(patternKey);\n                const invalidIndexes: any[] = [];\n                value.forEach((item, index) => {\n                    if (!check.test(item.key)) invalidIndexes.push(index);\n                });\n                if (invalidIndexes.length) {\n                    const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternKey`);\n                    fieldErrors.push(customError ?? m('inputSchema.validation.arrayKeysInvalid', {\n                        rootName: 'input',\n                        fieldKey: property,\n                        invalidIndexes: invalidIndexes.join(','),\n                        pattern: patternKey,\n                    }));\n                }\n            }\n            // If patternValue is provided and editor is keyValue, then validate values of objecs in array\n            if (patternValue && editor === 'keyValue') {\n                const check = new RegExp(patternValue);\n                const invalidIndexes: any[] = [];\n                value.forEach((item, index) => {\n                    if (!check.test(item.value)) invalidIndexes.push(index);\n                });\n                if (invalidIndexes.length) {\n                    const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternValue`);\n                    fieldErrors.push(customError ?? m('inputSchema.validation.arrayValuesInvalid', {\n                        rootName: 'input',\n                        fieldKey: property,\n                        invalidIndexes: invalidIndexes.join(','),\n                        pattern: patternValue,\n                    }));\n                }\n            // If patternValue is provided and editor is stringList, then validate each item in array\n            } else if (patternValue && editor === 'stringList') {\n                const check = new RegExp(patternValue);\n                const invalidIndexes: any[] = [];\n                value.forEach((item, index) => {\n                    if (!check.test(item)) invalidIndexes.push(index);\n                });\n                if (invalidIndexes.length) {\n                    const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternValue`);\n                    fieldErrors.push(customError ?? m('inputSchema.validation.arrayValuesInvalid', {\n                        rootName: 'input',\n                        fieldKey: property,\n                        invalidIndexes: invalidIndexes.join(','),\n                        pattern: patternValue,\n                    }));\n                }\n            }\n        }\n        // Check that object items fit patternKey and patternValue\n        if (type === 'object' && value && typeof value === 'object') {\n            if (patternKey) {\n                const check = new RegExp(patternKey);\n                const invalidKeys: any[] = [];\n                Object.keys(value).forEach((key) => {\n                    if (!check.test(key)) invalidKeys.push(key);\n                });\n                if (invalidKeys.length) {\n                    const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternKey`);\n                    fieldErrors.push(customError ?? m('inputSchema.validation.objectKeysInvalid', {\n                        rootName: 'input',\n                        fieldKey: property,\n                        invalidKeys: invalidKeys.join(','),\n                        pattern: patternKey,\n                    }));\n                }\n            }\n            if (patternValue) {\n                const check = new RegExp(patternValue);\n                const invalidKeys: any[] = [];\n                Object.keys(value).forEach((key) => {\n                    const propertyValue = (value as Record<string, any>)[key];\n                    if (typeof propertyValue !== 'string' || !check.test(propertyValue)) invalidKeys.push(key);\n                });\n                if (invalidKeys.length) {\n                    const customError = getCustomErrorMessage(inputSchema, `properties/${property}/patternValue`);\n                    fieldErrors.push(customError ?? m('inputSchema.validation.objectValuesInvalid', {\n                        rootName: 'input',\n                        fieldKey: property,\n                        invalidKeys: invalidKeys.join(','),\n                        pattern: patternValue,\n                    }));\n                }\n            }\n        }\n\n        // Additional validation for secret fields\n        if (isSecret && value && typeof value === 'string') {\n            // If the value is a valid encrypted string for the field type,\n            // we check if the field schema is likely to be still valid (is unchanged from the time of encryption).\n            if (isEncryptedValueForFieldType(value, type) && !isEncryptedValueForFieldSchema(value, properties[property])) {\n                // If not, we add an error message to the field errors and user needs to update the value in the input editor.\n                fieldErrors.push(m('inputSchema.validation.secretFieldSchemaChanged', { fieldKey: property }));\n            }\n        }\n\n        if (fieldErrors.length > 0) {\n            const message = fieldErrors.join(', ');\n            errors.push({ fieldKey: property, message });\n        }\n    });\n\n    return errors;\n}\n\n/**\n * This functions parses all given JSON and then takes each of the jsFields.\n * Then if the field:\n * - is valid JS single function it replaces its single line string with a function delacation.\n * - is valid multiline JS code then replaces its single line string with `multiline` string\n * Then stringifies the code with given number of jsonSpacing spaces and finally prefixes whole\n * stringified JSON except the first line with globalSpacing spaces.\n */\nexport function makeInputJsFieldsReadable(json: string, jsFields: string[], jsonSpacing = 4, globalSpacing = 0): string {\n    const parsedJson = JSON.parse(json);\n    const replacements: Record<string, any> = {};\n\n    jsFields.forEach((field) => {\n        let maybeFunction = parsedJson[field];\n        if (!maybeFunction || typeof maybeFunction !== 'string') return;\n\n        let ast;\n        try {\n            ast = parse(maybeFunction, { ecmaVersion: 'latest' });\n        } catch {\n            // Don't do anything in a case of invalid JS code.\n            return;\n        }\n\n        const isMultiline = maybeFunction.includes('\\n');\n        const isSingleFunction = ast\n            && ast.body.length === 1\n            && (\n                ast.body[0].type === 'FunctionDeclaration'\n                || (ast.body[0].type === 'ExpressionStatement' && ast.body[0].expression.type === 'ArrowFunctionExpression')\n            );\n\n        // If it's not a function declaration or multiline JS code then we do nothing.\n        if (!isSingleFunction && !isMultiline) return;\n\n        const spaces = (new Array(isSingleFunction ? jsonSpacing : jsonSpacing * 2)).fill(' ').join('');\n        maybeFunction = maybeFunction\n            .split('\\n').join(`\\n${spaces}`) // This prefixes each line with spaces.\n            .trim(); // Trim whitespace on both sides\n\n        const replacementValue = isSingleFunction\n            ? maybeFunction.replace(/[;]+$/g, '') // Remove trailing semicolons\n            : `\\`${maybeFunction}\\``;\n        const replacementToken = `<<<REPLACEMENT_TOKEN:${Math.random()}>>>`;\n        replacements[replacementToken] = replacementValue;\n        parsedJson[field] = replacementToken;\n    });\n\n    let niceJson = JSON.stringify(parsedJson, null, jsonSpacing);\n\n    Object.entries(replacements).forEach(([replacementToken, replacementValue]) => {\n        niceJson = niceJson.replace(`\"${replacementToken}\"`, replacementValue);\n    });\n\n    const globalSpaces = (new Array(globalSpacing)).fill(' ').join('');\n    niceJson = niceJson.split('\\n').join(`\\n${globalSpaces}`);\n\n    return niceJson;\n}\n\nconst DRAFT_2019_09_META_SCHEMA = 'https://json-schema.org/draft/2019-09/schema';\n\nexport function ensureAjvSupportsDraft2019(ajvInstance: Ajv) {\n    const metaSchema = ajvInstance.getSchema(DRAFT_2019_09_META_SCHEMA);\n    if (!metaSchema) {\n        throw new Error(\n            `The provided Ajv instance does not support draft-2019-09 (missing meta-schema ${DRAFT_2019_09_META_SCHEMA}).`,\n        );\n    }\n}\n\n/**\n * Validates that the provided pattern is a valid and safe regular expression.\n * @param pattern The regular expression pattern to validate.\n * @param fieldKey The field key where the pattern is used (for error messages).\n */\nexport function validateRegexpPattern(pattern: string, fieldKey: string) {\n    try {\n        // Validate that the pattern is a valid regular expression\n        // eslint-disable-next-line\n        new RegExp(pattern);\n    } catch {\n        const message = m('inputSchema.validation.regexpNotValid', { pattern, fieldKey });\n        throw new Error(`Input schema is not valid (${message})`);\n    }\n\n    // TODO: add check for safe regex but figure out how to avoid false positives with some valid regexes\n    // Check if the regex is safe (to avoid ReDoS attacks)\n    // if (!safe(regex)) {\n    //     const message = m('inputSchema.validation.regexpNotSafe', { pattern, fieldKey });\n    //     throw new Error(`Input schema is not valid (${message})`);\n    // }\n}\n"],"mappings":"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","names":["useApifyProxy","proxyUrls","definition"]}