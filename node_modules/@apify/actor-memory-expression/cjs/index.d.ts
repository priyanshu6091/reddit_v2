import { EvalFunction } from 'mathjs';

type ActorRunOptions = {
    build?: string;
    timeoutSecs?: number;
    memoryMbytes?: number;
    diskMbytes?: number;
    maxItems?: number;
    maxTotalChargeUsd?: number;
    restartOnError?: boolean;
};
type MemoryEvaluationContext = {
    runOptions: ActorRunOptions;
    input: Record<string, unknown>;
};
type CompilationCache = {
    get: (expression: string) => Promise<EvalFunction | null>;
    set: (expression: string, compilationResult: EvalFunction) => Promise<void>;
    size: () => Promise<number>;
};
type CompilationResult = EvalFunction;

declare const DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH = 1000;
/**
 * Evaluates a dynamic memory expression string using the provided context.
 * Result is rounded to the closest power of 2 and clamped within allowed limits.
 *
 * @param defaultMemoryMbytes The string expression to evaluate (e.g., `get(input, 'urls.length', 10) * 1024` for `input = { urls: ['url1', 'url2'] }`).
 * @param context The `MemoryEvaluationContext` (containing `input` and `runOptions`) available to the expression.
 * @param options.cache Optional synchronous cache. Since compiled functions cannot be saved to a database/Redis, they are kept in local memory.
 * @returns The calculated memory value rounded to the closest power of 2 and clamped within allowed limits.
*/
declare const calculateRunDynamicMemory: (defaultMemoryMbytes: string, context: MemoryEvaluationContext, options?: {
    cache: CompilationCache;
} | undefined) => Promise<number>;

export { type ActorRunOptions, type CompilationCache, type CompilationResult, DEFAULT_MEMORY_MBYTES_EXPRESSION_MAX_LENGTH, type MemoryEvaluationContext, calculateRunDynamicMemory };
